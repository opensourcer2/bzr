<refentry id="gladeui-glade-parser">
<refmeta>
<refentrytitle>glade-parser</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>GLADEUI Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>glade-parser</refname><refpurpose></refpurpose>
</refnamediv>

<refsynopsisdiv><title>Synopsis</title>

<synopsis>

#include &lt;glade.h&gt;


#define     <link linkend="CAST-BAD:CAPS">CAST_BAD</link>
            <link linkend="GladePropInfo">GladePropInfo</link>;
            <link linkend="GladeSignalInfo">GladeSignalInfo</link>;
            <link linkend="GladeAtkActionInfo">GladeAtkActionInfo</link>;
            <link linkend="GladeAccelInfo">GladeAccelInfo</link>;
            <link linkend="GladeWidgetInfo">GladeWidgetInfo</link>;
            <link linkend="GladeChildInfo">GladeChildInfo</link>;
            <link linkend="GladeInterface">GladeInterface</link>;
            <link linkend="GladeAtkRelationInfo">GladeAtkRelationInfo</link>;
            <link linkend="GladePackingDefault">GladePackingDefault</link>;
<link linkend="GladeInterface">GladeInterface</link>* <link linkend="glade-interface-new">glade_interface_new</link>         (void);
<link linkend="GladeInterface">GladeInterface</link>* <link linkend="glade-parser-parse-file">glade_parser_parse_file</link>     (const <link linkend="gchar">gchar</link> *file,
                                             const <link linkend="gchar">gchar</link> *domain);
<link linkend="GladeInterface">GladeInterface</link>* <link linkend="glade-parser-parse-buffer">glade_parser_parse_buffer</link>   (const <link linkend="gchar">gchar</link> *buffer,
                                             <link linkend="gint">gint</link> len,
                                             const <link linkend="gchar">gchar</link> *domain);
<link linkend="void">void</link>        <link linkend="glade-interface-destroy">glade_interface_destroy</link>         (<link linkend="GladeInterface">GladeInterface</link> *interface);
<link linkend="void">void</link>        <link linkend="glade-interface-dump">glade_interface_dump</link>            (<link linkend="GladeInterface">GladeInterface</link> *interface,
                                             const <link linkend="gchar">gchar</link> *filename);
<link linkend="gboolean">gboolean</link>    <link linkend="glade-interface-dump-full">glade_interface_dump_full</link>       (<link linkend="GladeInterface">GladeInterface</link> *interface,
                                             const <link linkend="gchar">gchar</link> *filename,
                                             <link linkend="GError">GError</link> **error);

</synopsis>
</refsynopsisdiv>









<refsect1>
<title>Description</title>
<para>

</para>
</refsect1>

<refsect1>
<title>Details</title>
<refsect2>
<title><anchor id="CAST-BAD:CAPS"/>CAST_BAD</title>
<indexterm><primary>CAST_BAD</primary></indexterm><programlisting>#define CAST_BAD (gchar *)
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="GladePropInfo"/>GladePropInfo</title>
<indexterm><primary>GladePropInfo</primary></indexterm><programlisting>typedef struct {
    gchar *name;
    gchar *value;
    gchar *comment;
    guint  translatable : 1;
    guint  has_context : 1;
} GladePropInfo;
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="GladeSignalInfo"/>GladeSignalInfo</title>
<indexterm><primary>GladeSignalInfo</primary></indexterm><programlisting>typedef struct {
    gchar *name;
    gchar *handler;
    gchar *object; /* represents userdata, if lookup is FALSE, then do connect_object with a
                    * widget looked up by name, otherwise g_module_lookup() */
    guint after : 1;
    guint lookup : 1;
} GladeSignalInfo;
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="GladeAtkActionInfo"/>GladeAtkActionInfo</title>
<indexterm><primary>GladeAtkActionInfo</primary></indexterm><programlisting>typedef struct {
    gchar *action_name;
    gchar *description;
} GladeAtkActionInfo;
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="GladeAccelInfo"/>GladeAccelInfo</title>
<indexterm><primary>GladeAccelInfo</primary></indexterm><programlisting>typedef struct {
    guint key;
    GdkModifierType modifiers;
    gchar *signal;
} GladeAccelInfo;
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="GladeWidgetInfo"/>GladeWidgetInfo</title>
<indexterm><primary>GladeWidgetInfo</primary></indexterm><programlisting>typedef struct {
    GladeWidgetInfo *parent;

    gchar *classname;
    gchar *name;

    GladePropInfo *properties;
    guint n_properties;

    GladePropInfo *atk_props;
    guint n_atk_props;

    GladeSignalInfo *signals;
    guint n_signals;
	
    GladeAtkActionInfo *atk_actions;
    guint n_atk_actions;

    GladeAtkRelationInfo *relations;
    guint n_relations;

    GladeAccelInfo *accels;
    guint n_accels;

    GladeChildInfo *children;
    guint n_children;
} GladeWidgetInfo;
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="GladeChildInfo"/>GladeChildInfo</title>
<indexterm><primary>GladeChildInfo</primary></indexterm><programlisting>typedef struct {
    GladePropInfo *properties;
    guint n_properties;

    GladeWidgetInfo *child;
    gchar *internal_child;
} GladeChildInfo;
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="GladeInterface"/>GladeInterface</title>
<indexterm><primary>GladeInterface</primary></indexterm><programlisting>typedef struct {
    gchar **requires;
    guint n_requires;

    GladeWidgetInfo **toplevels;
    guint n_toplevels;

    GHashTable *names;

    GHashTable *strings;
} GladeInterface;
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="GladeAtkRelationInfo"/>GladeAtkRelationInfo</title>
<indexterm><primary>GladeAtkRelationInfo</primary></indexterm><programlisting>typedef struct {
    gchar *target;
    gchar *type;
} GladeAtkRelationInfo;
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="GladePackingDefault"/>GladePackingDefault</title>
<indexterm><primary>GladePackingDefault</primary></indexterm><programlisting>typedef struct {
    gchar  *id;
    gchar  *value;
} GladePackingDefault;
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="glade-interface-new"/>glade_interface_new ()</title>
<indexterm><primary>glade_interface_new</primary></indexterm><programlisting><link linkend="GladeInterface">GladeInterface</link>* glade_interface_new         (void);</programlisting>
<para>
</para>
<para>

</para><variablelist role="params">
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>a newly allocated GladeInterface.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="glade-parser-parse-file"/>glade_parser_parse_file ()</title>
<indexterm><primary>glade_parser_parse_file</primary></indexterm><programlisting><link linkend="GladeInterface">GladeInterface</link>* glade_parser_parse_file     (const <link linkend="gchar">gchar</link> *file,
                                             const <link linkend="gchar">gchar</link> *domain);</programlisting>
<para>
This function parses a Glade XML interface file to a GladeInterface
object (which is libglade's internal representation of the
interface data).
</para>
<para>
Generally, user code won't need to call this function.  Instead, it
should go through the GladeXML interfaces.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>file</parameter>&nbsp;:</term>
<listitem><simpara> the filename of the glade XML file.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>domain</parameter>&nbsp;:</term>
<listitem><simpara> the translation domain for the XML file.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the GladeInterface structure for the XML file.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="glade-parser-parse-buffer"/>glade_parser_parse_buffer ()</title>
<indexterm><primary>glade_parser_parse_buffer</primary></indexterm><programlisting><link linkend="GladeInterface">GladeInterface</link>* glade_parser_parse_buffer   (const <link linkend="gchar">gchar</link> *buffer,
                                             <link linkend="gint">gint</link> len,
                                             const <link linkend="gchar">gchar</link> *domain);</programlisting>
<para>
This function is similar to glade_parser_parse_file, except that it
parses XML data from a buffer in memory.  This could be used to
embed an interface into the executable, for instance.
</para>
<para>
Generally, user code won't need to call this function.  Instead, it
should go through the GladeXML interfaces.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>buffer</parameter>&nbsp;:</term>
<listitem><simpara> a buffer in memory containing XML data.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>len</parameter>&nbsp;:</term>
<listitem><simpara> the length of <parameter>buffer</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>domain</parameter>&nbsp;:</term>
<listitem><simpara> the translation domain for the XML file.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the GladeInterface structure for the XML buffer.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="glade-interface-destroy"/>glade_interface_destroy ()</title>
<indexterm><primary>glade_interface_destroy</primary></indexterm><programlisting><link linkend="void">void</link>        glade_interface_destroy         (<link linkend="GladeInterface">GladeInterface</link> *interface);</programlisting>
<para>
Frees a GladeInterface structure.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>interface</parameter>&nbsp;:</term>
<listitem><simpara> the GladeInterface structure.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="glade-interface-dump"/>glade_interface_dump ()</title>
<indexterm><primary>glade_interface_dump</primary></indexterm><programlisting><link linkend="void">void</link>        glade_interface_dump            (<link linkend="GladeInterface">GladeInterface</link> *interface,
                                             const <link linkend="gchar">gchar</link> *filename);</programlisting>
<para>
This function dumps the contents of a GladeInterface into a file as
XML.  It was originaly intended as a debugging tool.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>interface</parameter>&nbsp;:</term>
<listitem><simpara> the GladeInterface
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>filename</parameter>&nbsp;:</term>
<listitem><simpara> the filename to write the interface data to.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="glade-interface-dump-full"/>glade_interface_dump_full ()</title>
<indexterm><primary>glade_interface_dump_full</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>    glade_interface_dump_full       (<link linkend="GladeInterface">GladeInterface</link> *interface,
                                             const <link linkend="gchar">gchar</link> *filename,
                                             <link linkend="GError">GError</link> **error);</programlisting>
<para>
This function dumps the contents of a GladeInterface into a file as
XML.  It is used by glade to write glade files.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>interface</parameter>&nbsp;:</term>
<listitem><simpara> the GladeInterface
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>filename</parameter>&nbsp;:</term>
<listitem><simpara> the filename to write the interface data to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GError"><type>GError</type></link> for error handleing.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>whether the write was successfull or not.
</simpara></listitem></varlistentry>
</variablelist></refsect2>

</refsect1>




</refentry>
